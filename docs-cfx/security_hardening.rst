Security Hardening
------------------

The following describes a high-security, best-practice system setup of
Crossbar.io Fabric and application components.

.. contents:: :local:

--------------

Operating Systems
.................

    **Summary: use Debian, Ubuntu Server or Ubuntu Core**

Write me.

--------------

Going to Production
...................

We have a series of hints and tips `going to
production <http://crossbar.io/docs/Going-to-Production/>`__ with
Crossbar.io that also touch on security aspects.

--------------

Host Firewall
.............

    **Summary: use Linux iptables and deny any traffic but in- and
    outgoing traffic for TCP/443 (HTTPS and secure WebSocket).**

It is highly recommended to run a kernel based, stateful, layer 4
firewall on the host running Crossbar.io Fabric.

On Linux systems running Ubuntu Server eg, this often means Linux
**iptables** to access and configure the Linux kernel firewall.

The recommended host firewall configuration is as follows:

1. **allow incoming** traffic on port **TCP/443 (secure Web and
   WebSocket)** *incoming* on the network interface *facing the clients*
   that should connect to this Crossbar.io Fabric node
2. **allow outgoing** traffic to port **TCP/443 (secure Web and
   WebSocket)** *outgoing* on the network interface *facing the public
   Internet* with the CFC uplink connection for node management, or
   router-to-router links to other CF nodes
3. **allow outgoing** traffic to port **UDP/53 (DNS)** *outgoing* on the
   network interface *facing the public internet*
4. **deny all other** traffic

Possible exceptions:

-  when the clients connecting might happend to try port 80 (insecure)
   instead of 443 (secure), port 80 could be opened as well, as long as
   the node is configured to redirect that to port 443 (see other
   chapter here).
-  when the host is to be managed, you might consider opening port 22
   for SSH, possibly further restricted to originating interface or
   network (only internal). However, running a SSH daemon must be
   considered carefully.
-  You might also consider enabling at least ICMP ping requests and
   responses, so that the host can be pinged for administration
   purposes. As these ICMP messages are generated by the kernel, this
   should be safe.

--------------

Host Network Segregation
........................

    **Summary: if possible, use separate networks and interfaces for
    public Internet facing, and private clients facing sides**

Write me.

--------------

Running Dockerized
..................

    **Summary: use our official Docker images for Crossbar.io Fabric.**

Using Docker is our recommended way of `Getting Started with
Crossbar.io <http://crossbar.io/docs/Getting-Started/>`__.

Crossbar.io Fabric is currently available as a Docker image, and it will
be available as a Ubuntu Core snap.

**You should only run Crossbar.io Fabric from our official Docker
images** which are available on DockerHub here:

-  `Crossbar.io Fabric
   (x86-64) <https://hub.docker.com/r/crossbario/crossbar-fabric/>`__
-  `Crossbar.io Fabric
   (armhf) <https://hub.docker.com/r/crossbario/crossbar-fabric-armhf/>`__
-  `Crossbar.io Fabric
   (aarch64) <https://hub.docker.com/r/crossbario/crossbar-fabric-aarch64/>`__

For production, usually only the following network ports are enabled for
the Docker container running Crossbar.io Fabric:

-  incoming TCP/80 (insecure WebSocket)
-  incoming TCP/443 (secure WebSocket)
-  outgoing TCP/443 (secure WebSocket)
-  outgoing UDP/53 (DNS)

The Crossbar.io Fabric node directory inside the Docker container should
be mounted from a host directory that is properly protected using
filesystem permissions.

--------------

Public facing transports
........................

    **Summary: use TLS-only with WebSocket**

For WAMP listening transports on Crossbar.io Fabric router workers that
accept connections from clients over the public Internet, we recommend
this transport:

-  WebSocket (with all serializers active)
-  WebSocket compression enabled
-  WebSocket `production settings
   recommendations <http://crossbar.io/docs/WebSocket-Options/#production-settings>`__

.. code:: javascript

    {
        "type": "websocket",
        "url": "wss://wamp.example.com",
        "serializers": [
            "cbor", "msgpack", "ubjson", "json"
        ],
        "options": {
            "enable_webstatus": true,
            "max_frame_size": 1048576,
            "max_message_size": 1048576,
            "auto_fragment_size": 65536,
            "fail_by_drop": true,
            "open_handshake_timeout": 2500,
            "close_handshake_timeout": 1000,
            "auto_ping_interval": 10000,
            "auto_ping_timeout": 5000,
            "auto_ping_size": 12,
            "auto_ping_restart_on_any_traffic": true,
            "compression": {
                "deflate": {
                    "request_no_context_takeover": false,
                    "request_max_window_bits": 13,
                    "no_context_takeover": false,
                    "max_window_bits": 13,
                    "memory_level": 5
                }
            }
        }
    }

Further, we recommend to redirect port 80 to 443

.. code:: javascript

    {
        "type": "web",
        "endpoint": {
            "type": "tcp",
            "port": 80
        },
        "paths": {
            "/": {
                "type": "redirect",
                "url": "https://wamp.example.com"
            }
        }
    }

and run exclusively over TLS and `secure
WebSocket <http://crossbar.io/docs/Secure-WebSocket-and-HTTPS/>`__.

.. code:: javascript

    "endpoint": {
        "type": "tcp",
        "port": 443,
        "tls": {
            "key": "server.key",
            "certificate": "server.crt",
            "chain_certificates": [
                "lets-encrypt-x3-cross-signed.pem"
            ],
            "dhparam": "dhparam.pem",
            "ciphers": "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256"
        }
    },
    "options": {
        "hsts": true,
        "hsts_max_age": 31536000
    },

A couple of noteworthy thing about this TLS configuration:

-  it runs TLS on standard port TCP/443
-  it uses
   `HSTS <https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security>`__
   with a long lifetime
-  it use a host generated Diffie-Hellman parameter file
-  it uses a hand selected list of active ciphers in a specific order
-  it uses a Let's Encrypt server certificate

All of this combined leads to a A+ ranking on `SSL Labs
Test <https://www.ssllabs.com/ssltest/>`__.

It's recommended to test your final setup using above SSL Labs Test.
Don't forget to retest after configuration change touching the
transports configuration in Crossbar.io Fabric.

--------------

Backend Application Components
..............................

    **Summary: use Docker based app components connected over Unix
    domain sockets**

Backend application components are WAMP components (often Autobahn
based) that are run in the backend parts of an application, often on
cloud systems, that is system which are reachable in the public
Internet.

To integrate backend application components into the overall system, two
things are needed:

-  they need to run somewhere/somehow and also be started by someone
-  they need to connect (and possibly authenticate) to Crossbar.io
   Fabric nodes

--------------

Dockerizing Components
~~~~~~~~~~~~~~~~~~~~~~

    **Summary: package and run your app components as Docker images and
    containers**

The recommended setup runs backend application components in Docker
containers.

Each backend application component is run in a separate Docker
container, and the container image is derived of one of the official
Autobahn Docker images.

The actual application code and any additional dependencies can be
included in the user Docker image deriving of one of the official
Autobahn images.

Using Docker in this way comes with a couple of benefits:

-  exactly reproducible deployment of your components
-  run-time isolation in both security and resource consumption
-  allows simple and complete network isolation (see below)

--------------

Network Isolation
~~~~~~~~~~~~~~~~~

    **Summary: no need to allow any networking (ingoing and outgoing)
    for app containers**

When backend application components provide business logic only, and do
not need to talk to the outside world other than via WAMP and
Crossbar.io, then there is no need for the backend component to be given
*any* network access.

Such backend components do not need to listen for incoming network
connections, nor do they need to establish outgoing network connections
(other than WAMP, and for that, see below).

To achieve this kind of full network isolation is easy using Docker,
since when starting the backend application component in a Docker
container without providing a network for the container to connect to,
no networking (other than loopback) will be possible for the backend
application component.

--------------

Disk Isolation
~~~~~~~~~~~~~~

    **Summary: no need to mount any disk/filesystem to an app
    container.**

Backend components - in general - should not store data persistently on
disk. There should be database backed services elsewhere in overall
system. (there are exceptions of course)

Since we are running backend application components in Docker
containers, filesystem and disk isolation is already there. In
particular, applicaton component hosting Docker containers do not need
any specific block devices or filesystems mounted.

The one exception being private key files, eg for TLS client certificate
based authentication or for WAMP-cryptosign based authentication, both
methods being public-private key based.

But *backend* application components don't even need that - they can be
authenticated implicitly when using Unix domain sockets for transport
(see below).

--------------

Router Connections and Authentication
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    **Summary: use Unix domain sockets (per component) with
    WAMP/RawSocket-CBOR**

So how does the backend application component connect to Crossbar.io,
given that we have denied it *any* kind of network access - even to
another container (such as Crossbar.io) running on the same host!

**Unix domain sockets (UDS)** are like network sockets, but do not exist
in an IP namespace, but reside in the filesystem namespace.

And because of that, permissions to Unix domain sockets can be
controlled and enforced using filesystem permissions.

Further, because we start the backend application component in a Docker
container, we need to explicitly mount the Unix domain socket path into
the Docker container when starting.

To take this approach further, **recommended is running one separate
Unix domain socket for each backend application component** co-residing
on the host that runs the Crossbar.io Fabric node the component is
supposed to connect to.

When doing so, an additional benefit becomes obvious: because now
Crossbar.io Fabric essentially runs a separate transport for each
backend application component, it automatically knows that it must be
that component that is connecting. In other words, **backend application
components are implicitly authenticated**.

For the WAMP transport type used with backend application components,
recommended is:

-  RawSocket using CBOR
-  no TLS

In this case, TLS is not required, as the traffic between the backend
application component and Crossbar.io runs over a UDS, which means
through kernel, and protected from other user processes anyways.

--------------

Unneeded and Unwanted Features
..............................

Write me.

--------------

Static Web Content
~~~~~~~~~~~~~~~~~~

    **Summary: use a CDN.**

Crossbar.io Fabric, when used as a simple Web server for static content
is `pretty
fast <https://github.com/crossbario/crossbar-examples/tree/master/benchmark/web>`__.
Nginx is faster of course. Then who needs to push millions of Web
requests per second?

However, the point is not being able to saturate a 10GbE link using a
couple of cores on a single box in a data-center anyways.

The point with bringing static Web content to the masses with low
latency (!) is that you probably want a CDN.

CDNs deliver static content like nothing else. And this part of your
traffic is now completely managed by the CDN (= their problem!),
including fighting off DDoS attacks on a large scale.

--------------

Web Services
~~~~~~~~~~~~

    **Summary: don't use any. there are special packages for most of
    this stuff, or it is for deprecated old clients (which you also
    don't want to support, because they are a liability)**

Crossbar.io Fabric supports a rich set of `Web Transport
Services <http://crossbar.io/docs/Web-Transport-and-Services/>`__:

-  path
-  static
-  upload
-  websocket
-  longpoll
-  redirect
-  nodeinfo
-  reverseproxy
-  json
-  cgi
-  wsgi
-  resource
-  caller
-  publisher
-  webhook
-  schemadoc

These are all useful and good to use in different scenarios.

But in a security optimized setup, we only want the bare minimum of
Crossbar.io, which happens to be WAMP routing after all;)

So in a high security production setup, it is recommended to *not* run a
Web transport, and not run any Web transport services.

None of these are essential. All of these have other more specialized
solutions, like for example *general* Web and WebSocket (non WAMP)
reverse proxying is probably best done using Nginx or some special
reverse Web proxy package.

--------------

MQTT Bridge
~~~~~~~~~~~

    **Summary: don't use MQTT on new stuff and migrate old clients to
    WAMP in medium term**

--------------

Router Components
~~~~~~~~~~~~~~~~~

    **Summary: use Dockerized application components instead.**

Write me.

--------------

Container Workers and Components
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    **Summary: use Dockerized application components instead.**

Write me.

--------------

Guest Workers
~~~~~~~~~~~~~

    **Summary: use Dockerized application components instead.**

Write me.
